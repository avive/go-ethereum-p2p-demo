---
author:
- lash
date: |
    \
    v0.2
title: getting started with devp2p
---

Introduction {#introduction .unnumbered}
============

This document is work in progress. In the first version deemed fit for
release, this pink box will no longer be here.

These tutorials show you how to make communicate with each other using
the `go-ethereum` code base. They do *not* show you *how* to program,
nor does it provide entry-level familiarity to the `golang` programming
language, which `go-ethereum` is written in.

For the latter I can warmly recommend taking the official “go tour”, but
be warned; although `golang` aims at providing friendly access to fairly
low-level operations, it’s still fairly low-level. So if you come from
the less cumbersome environment of web-scripting and such, you’re
probably in for a challenge.

The Ethersphere, like its crypto comrades, dabbles quite a bit in moving
individual bytes around before crunching them with big number math.
However, most of the code we shall see fortunately manages to steer
clear of that, and concentrates on some nice, magic function calls that
spares us a few pints of elbow grease.

The meaty parts of this document are code examples that all centre on
runnable mini-applications that reveal features and structure in small
incremental steps. And they are even grouped in themes that
incrementally add to the complexity of components of the code stack that
we will be using in everyday p2p life.

In the current version of this document, the layers we will peel are as
follows:

1.  **The** ; connections and messages

2.  **Remote Procedure Calls**; defining and using APIs

3.  **Services**; bringing protocols and APIs together

4.  **Pss**: relay messages across peer-to-peer connections

p2p in Ethereum
===============

\[…\]

the code examples
=================

Server minimalism
-----------------

The best way to learn is to remove all distractions, so let’s stick with
the bare-bear necessities first. In this example we merely create an
*instance* of the , *start* it and stop it again. Not very useful, but
it’s the start of something great, promise!

By *starting* we mean that the `UDP` and `TCP` listener sockets are
opened, upon which the server will:

-   wait for connections

-   be able to connect to other

<!-- -->

    privkey, err := crypto.GenerateKey()
    if err != nil {
    	demo.Log.Crit("Generate private key failed", "err", err)
    }

The first step is to create the ’s *private key*. The public key derived
from it will be the public identity of the . Don’t worry; the private
key is generated by random, chosen from a range of numbers greater than
the particle count of the entire universe. It will be quite unique.

    cfg := p2p.Config{
    	PrivateKey: privkey,
    	Name:       common.MakeName("foo", "42"),
    }
    srv := p2p.Server{
    	Config: cfg,
    }

The private key is passed to the server’s configuration, along with an
arbitrary *name*, usually made up by an identifier describing its
codebase, architecture and version number. The name has no practical
significance in the scope of our tutorials, but it is a required field,
and kind of polite to take seriously. There are plenty of other settings
under the hood of the . Luckily, all of them will receive nice default
values when we fire things up.

    // attempt to start the server
    err = srv.Start()
    if err != nil {
    	demo.Log.Crit("Start p2p.Server failed", "err", err)
    }

    // inspect the resulting values
    nodeinfo := srv.NodeInfo()
    demo.Log.Info("server started", "enode", nodeinfo.Enode, "name", nodeinfo.Name,
    "ID", nodeinfo.ID, "IP", nodeinfo.IP)

    // bring down the server
    srv.Stop()

**The moment of truth.** If your computer doesn’t blow up before then,
you should see a log line in your console showing you some basic
information about your running server, along the lines of[^1]:

    	INFO [06-24|22:12:49] server started                           demolog=* enode=enode://92f6fa82[\ldots]dc0912ba@[::]:46851
    	name=foo/v42/linux/go1.8.3 ID=92f6fa82[\ldots]dc0912ba IP=:: caller=A1\_Server.go:32

An IP address has now been awarded to us, which spells good news for
future connectivity. Fair enough, the IP field here merely cites the
somewhat cryptic “::”, but this is shorthand for `localhost` so we’re
good.

The two fields of special interest to us are the `ID` and the ``. See
how they contain nearly the same thing? Or rather, how the `` contains
the `ID` and a bit more? Here’s how the entities we’ve met so far fit
together:

server

:   Holds a private key and controls ip connections.

ID

:   The one-of-a-kind public key of the , derived from its private key
    (the one we made up in the start of the example).

enode

:   An uri-string that is used when you want to tell a who to connect
    to, made up of the server’s ID (more on that next) along with the IP
    address and port number of the node.

Of course, every time a starts up it might have a different address or
port, so we need to know about those to reach out to it at all. But we
also want to make sure that the connection actually is for the in
question, and not some other shady node that popped up on that address
and port in the meantime. Therefore we also include the public key. And
if the public key doesn’t match, no soup for you.

Getting hooked up
-----------------

Now we bring up two of the servers as in the previous example and
connect them. That is, connect one to the other. They act as consenting
adults; the connection will be mutual, or none at all.

    func newServer(privkey *ecdsa.PrivateKey, name string, version string, port int) *p2p.Server {

    	// we need to explicitly allow at least one peer
    	// otherwise the connection attempt will be refused
    	cfg := p2p.Config{
    		PrivateKey: privkey,
    		Name:       common.MakeName(name, version),
    		MaxPeers:   1,
    	}
    	if port > 0 {
    		cfg.ListenAddr = fmt.Sprintf(":%d", port)
    	}
    	srv := &p2p.Server{
    		Config: cfg,
    	}
    	return srv
    }

The code is almost the same as before, except for two things:

We are specifying the *port* explicitly. It has a default value, but
when we are setting up two servers on the same host we need different
ports for them. Otherwise the OS will complain loudly.

Also, with the `MaxPeers` setting we’re telling the server that it will
allow one and only one peer to connect to it. Without this setting the
value will be 0, which means the node will play very hard-to-get and any
attempt of connecting will be coldly rejected. If you believe more is
merrier, which is usually the case in p2p networks, this setting will
usually be higher.

    	srv_one := newServer(privkey_one, "foo", "42", 0)
    	err = srv_one.Start()
    	if err != nil {
    		demo.Log.Crit("Start p2p.Server #1 failed", "err", err)
    	}

    	srv_two := newServer(privkey_two, "bar", "666", 31234)
    	err = srv_two.Start()
    	if err != nil {
    		demo.Log.Crit("Start p2p.Server #2 failed", "err", err)
    	}

In the same manner as before, we start the two servers. We give the
second different parameters for name, version and port.

    	// get the node instance of the second server
    	node_two := srv_two.Self()

    	// add it as a peer to the first node
    	// the connection and crypto handshake will be performed automatically
    	srv_one.AddPeer(node_two)

The `Self()` call on the server gives you back a object. This object
represents the server as a node, and contains all the information needed
for a connection. So we can simply pass this as an argument to the
aptly-named `AddPeer` method of the server.

    // give the connection a glimpse of time to complete
    time.Sleep(time.Millisecond * 100)

    // inspect the results
    demo.Log.Info("after add", "node one peers", srv_one.Peers(), "node two peers", srv_two.Peers())

The connection is created asynchronously, and might take a split second
to complete. So if we rush into proving that we now have a shiny new
peer in our connection list, we will most certainly be disappointed. So
we give it pleeenty of time a.k.a. 100 milliseconds to complete. In the
next section we’ll learn a way more clever way to do this. Anyway you
can rejoice for now: Connection is made. **Victory is ours**.

### A note on nodes

The term `node` used here is one of many notions of node in the
go-ethereum code base, which at some point surely will confuse you. This
flavor of node has to do with finding (discovering) nodes to connect to,
and connect to them. And this specific object holds information specific
to the connection, like IP information and an ID, or pretty much what
makes up the string we mentioned in the last section. See how it all
neatly fits together?

Know what’s going on
--------------------

So how to we get rid of that unaesthetic and unprecise timeout from the
last example? We use the , of course. When connections start and stop,
and when messages are sent and received, are emitted.

    // set up the event subscription on the first server
    eventC := make(chan *p2p.PeerEvent)
    sub_one := srv_one.SubscribeEvents(eventC)

All you have to do is pass a channel to the `SubscribeEvents` method of
the , and you will start receiving them through it.

    // listen for events
    go func() {
    	peerevent := <-eventC
    	demo.Log.Info("received peerevent", "type", peerevent.Type, "peer", peerevent.Peer)
    	quitC <- true
    }()

Then fork before the `AddPeer` call, and listen on the channel for an
event. Of course normally we would check what event it is, what peer it
came from and so on and so forth. In this case, however, we’re not
really doing much, so we know that the event will be of type “add” and
the peer will be the node we’re *not* subscribing to.

    // PeerEventType is the type of peer events emitted by a p2p.Server
    type PeerEventType string

    const (
    	// PeerEventTypeAdd is the type of event emitted when a peer is added
    	// to a p2p.Server
    	PeerEventTypeAdd PeerEventType = "add"

    	// PeerEventTypeDrop is the type of event emitted when a peer is
    	// dropped from a p2p.Server
    	PeerEventTypeDrop PeerEventType = "drop"

    	// PeerEventTypeMsgSend is the type of event emitted when a
    	// message is successfully sent to a peer
    	PeerEventTypeMsgSend PeerEventType = "msgsend"

    	// PeerEventTypeMsgSend is the type of event emitted when a
    	// message is successfully sent to a peer
    	PeerEventTypeMsgRecv PeerEventType = "msgrecv"
    )

    // PeerEvent is an event emitted when peers are either added or dropped from
    // a p2p.Server or when a message is sent or received on a peer connection
    type PeerEvent struct {
    	Type    PeerEventType   `json:"type"`
    	Peer    discover.NodeID `json:"peer"`
    	Error   string          `json:"error,omitempty"`
    	MsgCode *uint64         `json:"msg_code,omitempty"`
    	MsgSize *uint32         `json:"msg_size,omitempty"`
    }

A quick look in the `peer.go` file in the `p2p` package tells what kind
of we have, and how they’re stuctured.

    // receives when the event is received
    <-quitC

    // inspect the results
    demo.Log.Info("after add", "node one peers", srv_one.Peers(), "node two peers", srv_two.Peers())

    // terminate subscription
    sub_one.Unsubscribe()

When the connection is completed (on the node we’re subscribing to), we
output the logline as before. Don’t feel guilty about terminating the
subscription after just one item. You’ll get your money’s worth later.

[^1]: we will be truncating long hex strings in these tutorials. This is
    your last and final warning
